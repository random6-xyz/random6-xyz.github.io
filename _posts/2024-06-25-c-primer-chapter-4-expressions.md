---
layout: post
title: "[C++ Primer] Chapter 4 Expressions"
category: [C++]
date: 2024-06-25 13:45:00 +0900
tag: [C++, book]
description: summary of C++ Primer chapter 4
comments: false
---

- 이 장에서는 언어에서 정의한 연산자와 이 연산자를 내장 타입 피연산자에 적용하는 것에 초점을 맞춘다.
- 표현식 - 피연산자 하나 이상으로 구성하며 평가하면 결과를 반환한다.
- 가장 간단한 형식은 상수 또는 변수 하나이며, 이런 표현식의 결과는 변수 또는 상수의 값이다.

## 4.1 기초

### 4.1.1 기본 개념

- 연산자에는 단항 연산자(피연산자 1개), 이항 연산자(피연산자 2개), 삼항 연산자(피연산자 3개), 피연산자의 개수에 제한이 없는 경우도 있다.
- 연산자와 피연산자를 하나로 묶기
  - 연산자 우선순위와 결합법칙을 이해해야 한다.
- 피연산자 변환
  - 표현식을 평가하는 과정에서 종종 피연산자를 다른 타입으로 변환한다.
- 다중 정의한 연산자
  - 이미 존재하고 있는 연산자 기호에 이런 식으로 다른 의미를 부여하는 것
- 좌변 값과 우변 값
  - C++에서 모든 표현식은 우변 값고 좌변 값 중 하나이다. 이를 구별하는 것은 쉽지않다.
  - 우변 값이 필요할 때 좌변값을 대신 쓸 수 있으나 좌변 값이 필요할 때 우변값을 대신 쓸 수는 없다.

### 4.1.2 우선순위와 결합법칙

- 연산자가 둘 이상인 표현식은 복합 표현식이다. 이를 평가할 때는 피연산자를 연산자와 묶게 된다. 이때 묶는 방법은 우선순위와 결합법칙으로 결정된다.
- 괄호로 우선순위와 겷바법칙 재정의하기
  - 괄호를 사용해 일반적인 결합 순서를 재정의할 수 있다.
  - 괄호로 묶은 하위 표현식을 단위 하나로 간주해 평가한다.
- 우선순위와 결합법칙이 중요할 때
  - 우선순위가 프로그램의 올바른 결과에도 영향을 준다.

### 4.1.3 평가 순서

```cpp
cout << i << " " << ++i << endl;
```

- 연산자에 평가 순서를 지정하지 않고 표현식에서 같은 객체를 참조하면서 변경하면 오류이다. → 컴파일러에 따라 다른 결과가 나올 수 있다.
- 평가 순서, 우선순위, 결합법칙
  - 피연산자 평가 순서는 우선순위, 결합법칙과 관계 없다.
- 복합 표현식 다루기
  - 의심스러우면 프로그램에 필요한 논리대로 괄호를 사용해 표현식을 강제로 묶는다.
  - 피연산자의 값을 변경하면 그 피연산자를 같은 표현식 내 다른 곳에서 사용하지 않는다.

## 4.2 산술 연산자

- 단항  산술 연산자는 곱셈과 나눗셈 연산자보다 우선순위가 높으며 차례로 이항 덧셈과 뺄셈 연산자 순이다. 이 연산자는 모두 왼쪽 결합이다.

## 4.3 논리와 관계 연산자

- 관계 연산자에서는 산술 또는 포인터 타입을 피연산자로 취하고 논리 연산자에서는 `bool`로 변환할 수 있는 모든 타입을 피연산자로 취한다.
- 산술 표인터 피연산자 값이 0이면 `false`, 이 외에는 모두 `true`이다.
- 두 연산자에 대한 피연산자는 우변 값이고 결과 역시 우변 값이다.
- 논리 AND와 OR연산자
  - AND와 OR 모두 언제나 왼쪽 피연산자를 오른쪽보다 먼저 평가한다. 더욱이 왼쪽 피연산자만으로 결과를 결정할 수 없을 때만 오른쪽 피연산자를 평가한다. ← 단축 평가
- 논리 NOT 연산자 (!)
  - 해당 피연산자에 대한 진리 값의 역을 반환한다.
- 관계 연산자
  - `bool`값을 반환하고 왼쪽 결합이다.
- 상등 비교와 `bool` 상수
  - `if (val == true)`는 쓰지 않는 것이 더 좋다. 길고 직접적이지 않고, 틀린 결과가 나올 수 있다.

## 4.4 대입 연산자

- 대입 연산자에서 왼쪽 피연산자는 반드시 변경 가능한 좌변값이어야 한다.
- 대입 결과는 왼쪽 피연산자, 즉 좌변 값이다.
- 대입은 오른쪽 결합이다
  - 다른 이항연산자들과 달리 대입은 오른쪽 결합이다.
  - 연쇄적으로 대입을 할 수도 있다.
- 대입은 우선순위가 낮다
  - 대입은 관계 연산자보다 우선순위가 낮으므로 일반적으로 조건에 대입을 사용하면 괄호로 둘러싸야 한다.
- 상등과 대입 연산자를 헷갈리지 말자
  - `=`과 `==`을 조건문에 넣을 때 혼동하지 말자
- 복합 대입 연산자
  - `+=`, `-=`등이 있다. 성능이 대부분 크게 차이나지 않는다

## 4.5 증가와 감소 연산자

- 증가나 감소 연산자에는 전위형식과 후위 형식이 있다.
- 전위 형식 - 피연산자를 증가 시키고 **변경한 객체**를 결과로 반환한다.
- 후위 형식 - 피연산자를 증가 시키고 **변경하지 않은 값**을 결과로 반환한다.
- 후위 표현식은 필요할 때만 사용하자.
- 표현식 하나에서 역참조와 증가 결합하기
  - `cout << *ppp++ << end;` 이러한 표현식에 더 익숙해지자, 더 권장되는 방식이다
- 피연산자 평가 순서는 정해져 있지 않음을 기억한다.

## 4.6 멤버 접근 연산자

- 점 연산자는 클래스 타입 객체에서 멤버를 가져온다
- 화살표 연산자는 `ptr->mem`을  `(*ptr).mem`에 대한 동의어이다.
- 화살표 연산자는 포인터를 피연산자로 쓰고 좌변값을 반환한다. 점 연산자에서는 멤버를 가져올 대상 객체가 좌변값이면 좌변 값을 반환하고 그렇지 않으면 우변값을 결과로 반환한다.

## 4.7 조건 연산자

- `조건 ? 참일 때 : 거짓일 때`와 같은 꼴로 나타낼 수 있다.
- 결과는 표현식이 모두 좌변 값이거나 공통인 좌변 값 타입으로 변환할 수 있을 때 좌변 값이다. 그렇지 않으면 우변 값이다.
- 중첩한 조건 연산자
  - 중첩한 조건은 재빨리 이해하기 쉽지 않으므로 둘 또는 셋보다 많이 중첩하지 않는 것이 좋다.
- 출력 표현식에서 조건 연산자 사용하기
  - 조건 연산자는 우선순위가 꽤 낮으므로 큰 표현식에 조건 표현식을 넣을 때는 일반적으로 조건을 나타내는 하위 표현식을 괄호로 둘러싸야 한다.

## 4.8 비트 연산자

- 비트 연산자에선느 비트 모음으로 사용할 정수 타입을 피연산자로 취급한다.
- 비트 이동 연산자
  - 오른쪽 피연산자로 지시한 만큼 비트 이동한 왼쪽 피연산자의 복사본을 값으로 반환한다.
- 비트 NOT 연산자
  - 피연산자의 비트를 반전한 새로운 값을 생성한다.
- 비트 AND, OR, XOR 연산자
- 이동 연산자(별칭 IO 연산자)는 왼쪽 결합이다

## 4.9 `sizeof` 연산자

- `sizeof`연산자는 표현식이나 타입 이름의 크기를 바이트 단위로 반환한다
- 2가지 형식 → `sizeof (타입)`, `sizeof 표현식`

## 4.10 쉼표 연산자

- 쉼표 연산자에서는 피연산자 둘을 취하고 왼쪽에서 오른쪽으로 평가한다.
- 왼쪽 표현식은 평가 후 그 결과를 버리고, 오른쪽 표현식 결과가 쉼표 표현식의 결과이다.
- `for` 루프에서 많이 보인다.

## 4.11 타입 변환

- 암시적 변환 - 피연산자를 고옹 타입으로 변환할 수 있는 변환 집합, 프로그래머가 인지하지 못하는 사이에 자동으로 실행

### 4.11.1 산술 변환

- 일반적으로 정수값과 부동소수점 값이 있으면 부동 소수점으로 변환한다.
- 정수 승격
  - 작은 정수 타입을 더 큰 정수 타입으로 변환한다.
- 부호 없는 타입은 피연산자
  - 연산자의 피연산자 타입이 서로 다르면 일반적으로 피연산자를 공통 타입으로 변환한다.

### 4.11.2 다른 암시적 변환

- 배열을 포인터로 변환 - 표현식 대부분에서 배열을 사용하면 이 배열은 자동으로 해당 배열의 첫 요소에 대한 포인터로 변환한다.
- 포인터 변환
- `bool`로 변환 - 산술 또는 포인터 타입을 자동으로 `bool`로 변환한다.
- `const`로 변환 - `const`가 아닌 타입에 대한 포인터를 `const`인 해당 타입에 대한 포인터로 변환할 수 있으며 참조자일 경우에도 비슷하다.
- 클래스 타입에서 정의한 변환

### 4.11.3 명시적 변환

- 캐스트를 쓴다
- 명명한 캐스트
  - `캐스트-이름<타입> 표현식` 꼴로 쓸 수 있다.
- `static_cast`
  - 하위 `const`를 포함한 변환을 제외하고 모든 명확한 타입 변환에 쓸 수 있다.
- `const_cast`
  - `const_cast`에서는 피연산자의 하위 `const`만 변경한다.
- `reinterpret_cast`
  - 일반적으로 피연산자 비트 구성 형식을 저수준에서 재해석한다.
- 구식 캐스트
  - `type (expr)`, `(type) expr`

## 4.12 연산자 우선순위 표

- 책 참고
