---
layout: post
title: "[OS] Chapter 3 프로세스와 스레드"
category: [OS]
date: 2024-08-05 17:40:00 +0900
tag: [OS, book]
description: summary of OS chapter 3
comments: false
---

- 프로세스가 생성된 후 작업을 마칠 때까지 어떤 상태를 거치고, 각 상태의 특징, 프로세스 제어 블록에 대해 살펴본다.
- 스레드와 프로세스를 비교해본다.

## 1. 프로세스의 개요

### 1.1 프로세스의 개념

- 프로그램은 저장장치에 저장되어 있는 정적인 상태이고, 프로세스는 실행을 위해 메모리에 올라온 동적인 상태이다.
- 레시피가 프로그램, 요리가 프로세스로 비유할 수 있다.

### 1.2 요리사 모형에의 비유

- 레스토랑에서 요리를 주문하여 나오기까지의 과정을 살펴보자.

#### 1.2.1 주문서의 역할

- 주문서에 담긴 내용 - 주문 순서, 일련번호, 테이블 번호, 몇 명, 요리, 특별 주문 사항

#### 1.2.2 일괄 작업 방식의 요리

- 가장 간단한 요리 제공 방식은 일괄 작업 시스템이다. ← 한번에 하나의 작업만 처리하는 것, 테이블이 하나인 식당
- 주문 목록은 큐로 처리된다.

#### 1.2.3 시분할 방식의 요리

- CPU가 시간을 쪼개어 여러 프로세스에 적당히 배분함으로써 동시에 실행하는 것처럼 느껴지게 한다.
- 주문서가 주문 목록에 올라온다는 것은 요리의 시작을 의미한다. 주문 목록이 삭제되면 해당 요리 작업이 종료되었음을 의미한다.

#### 1.2.4 시분할 방식에서의 예상치 못한 상황 처리

- 지연되는 요리가 있으면 대기 목록에서 기다렸다가 다시 제작 목록으로 옮긴다.
- 언제 다시 시작될 지 모르는 주문서는 보류 목록으로 옮기고, 손님이 원하면 주문 목록으로 보낸다.

### 1.3 프로그램에서 프로세스로의 전환

- 프로세스는 컴퓨터 시스템의 작업 단위로 테스크라고도 부른다.
- 프로그램이 프로세스로 전환될 때 일어나는 일
  - 프로그램을 메모리의 적당한 위치로 가져온다. + 주문서에 해당 작업 지시서를 만든다 → 프로세스 제어 블록(주문서)을 의미한다.
- 프로세스 제어블록에 있는 대표적인 3가지
  - 프로세스 구분자 - 프로세스를 구분하는 구분자
  - 메모리 관련 정보 - 실행하려는 프로세스의 메모리 상의 위치, 경계 레지스터, 한계 레지스터
  - 각종 중간값 - 어디까지 실행되었는지 표시하는 용도, 프로그램 카운터, 레지스터들
- 프로세스가 종료되면 프로세스가 메모리에서 삭제되고 프로세스 제어 블록도 폐기된다.
- 프로세스 = 프로그램 + 프로세스 제어블록
- 컴퓨터 내에는 사용자가 실행한 프로세스만 있는 것이 아니다. → 사용자 프로세스와 운영체제의 커널 프로세스가 섞여서 실행된다.

### 1.4 프로세스의 상태

- 운영체제에서도 여러가지 이유로 프로세스 상태가 변화된다.
- 일괄 작업 시스템의 프로세스 상태는 생성, 실행, 완료이다.
- 시분할 시스템에서의 프로세스 상태는 일괄 작업 시스템보다 복잡하다. ← 중간에 다른 프로세스에 CPU를 넘겨주는 일이 빈번하기 때문이다.

#### 1.4.1 프로세스의 네 가지 상태

- 생성 상태 - 프로세스가 메모리에 올라와 실행 준비를 완료한 상태이다. 프로세스 제어 블록이 생성된다.
- 준비 상태 - 생성된 프로세스가 CPU를 얻을 때까지 기다리는 상태이다. 레스토랑의 예에서는 주문 목록이 준비 상태에 해당한다.
- 실행 상태 - 준비 상태에 있는 프로세스 중 하나가 CPU를 얻어 실제 작업을 수행한다. 프로세스는 자신의 작업이 끝날 때까지 준비상태와 실행 상태를 왔다 갔다 한다.
- 완료 상태 - 실행 상태의 프로세스가 주어진 시간 동안 작업을 마치면 완료 상태로 진입한다. ← 프로세스 제어 블록이 사라진 상태를 의미한다.
- CPU 스케줄러 - 다음 실행할 프로세스를 선정하는 일을 하는 것, 준비상태 맨 앞에 있는 프로세스 제어 블록을 CPU에 전달하여 작업이 이루어지게 한다.
  - dispatch - 프로세서 하나를 준비 상태 → 실행 상태
- 프로세스는 실행 상태에서 일정 시간 동안 작업을 하는데, 프로세스에 배당된 작업 시간을 타임 슬라이스, 타임 퀀텀이라고 부른다.
  - 하나의 타임 슬라이스 안에 작업을 끝내지 못 했다면 다시 준비 상태로 간다. 이를 타임 아웃이라고 한다.
- CPU는 새로운 프로세스가 들어오면 알람을 맞춰둔다. 시간이 다되면 인터럽트를 사용해 CPU에게 알려준다.

#### 1.4.2 프로세스의 다섯 가지 상태

- 입출력을 요구한 프로세스가 입출력이 완료될 때까지 기다리는 상태를 대기 상태라고 한다. 이는 작업의 효율성을 높이기 위해 입출력을 요청한 프로세스를 실행 상테에 두지 않고 대기 상태로 옮기는 것이다. → CPU는 준비 상태의 프로세스를 실행 상태로 만든다.
- 대기 상태의 프로세스는 요청한 입출력이 완료되면 입출력 관리자로부터 인터럽트를 받는다. 대기 상태에서 입출력이 끝난 프로세스는 실행 상태로 가지 않고 준비 상태로 돌아가 자기 차례를 기다린다.
- 프로그램의 다섯가지 상태
  - 생성 상태 - 프로그램이 메모리에 올라가고 OS로 부터 프로세스 제어 블록을 할당받은 상태로, 준비 상태에서 자기 순서를 기다리며, 프로세스 제어 블록도 같이 준비사태로 옮겨진다.
  - 준비 상태 - 실행 대기 중인 모든 프로세스가 자기 순서를 기다리는 상태이다. 준비 큐에서 기다리며 CPU 스케줄러가 관리한다.
    - dispatch(PID) - 프로세스 제어 블록을 선택하는 작업을 처리하는 명령
  - 실행 상태 - 프로세스가 CPU를 할당받아 실행되는 상태이다. 실행 상태에 들어가는 프로세스는 CPU의 개수만큼 이다.
    - 타임 슬라이스가 지나면 timeout(PID)가 실행된다. → 프로세스 제어 블록을 실행 상태에서 준비 상태로 옮긴다.
    - 끝나면 exit(PID)가 실행되어 프로세스가 종료된다.
    - 실행 상태에 있는 프로세스가 입출력을 요청하면 CPU는 입출력 관리자에게 입출력을 요청하고 block(PID)를 실행한다.
  - 대기 상태 - 실행 상태에 있는 프로세스가 입출력을 요청하면 입출력이 완료될 때까지 기다리는 상태로 wait status라고도 한다. 대기 상태의 프로세스는 큐에서 기다린다.
    - wakeup(PID) - 대기 상태에 잇는 여러 프로세스 중 입출력 인터럽트로 깨어날 프로세스를 찾는 것 → 해당 프로세스의 프로세스 제어 블록이 준비 상태로 이동하게 된다.
  - 완료 상태 - 프로세스가 종료되는 상태이다. 메모리에서 삭제하고 프로세스 제어 블록을 폐기한다.
    - exit() - 정상적인 종료
    - 코어 덤프 - 정상적이지 않은 종료를 하면 디버깅하기 위해 강제 종료 직전의 메모리 상태를 저장장치로 옮기느 것

#### 1.4.3 휴식 상태와 보류 상태

- 대부분의 프로세스는 생성, 준비, 실행, 대기, 완료 상태로 운영되며 이 다섯 가지 상태를 활성 상태라고 한다. ↔ 이와 반대로 대기 상태가 있다.
- 휴식 상태 - 프로세스가 작업을 일시적으로 쉬고 있는 상태이다. 사용하던 데이터가 메모리에 그대로 있고 프로세스 제어 블록도 유지되므로 프로세스는 멈춘 지점에서부터 재시작할 수 있다.
- 보류 상태 - 프로세스가 메모리에서 잠시 쫓겨난 상태로 휴식 상태와 차이가 있다. 일시 정지 상태라고 볼 수 있고 보류 상태와 비교하여 일반적인 프로세스 상태를 활성 상태라고 한다.
  - 보류 상태로 들어가는 경우
    - 메모리가 꽉 찼을 때
    - 프로그램에 오류가 있어서 실행을 미루어야 할 때
    - 악의적인 공격 프로세스라고 판단될 때
    - 매우긴 주기로 반복되는 프로세스라 메모리 밖으로 쫓아내도 큰 문제가 없을 때
    - 입출력을 기다리는 프로세스의 입출력이 계속 지연될 때
  - 보류 상태에 들어간 프로세스는 메모리 밖으로 쫓겨나 스왑 영역에 보관된다.
  - 보류 상태는 대기 상테에서 옮겨진 보류 대기 상태와 준비 상태에서 옮겨진 보류 준비 상태로 구분되며, 각 상태에서 재시작하면 원래의 활성 상태로 들어간다.

## 2. 프로세스 제어 블록과 문맥 교환

### 2.1 프로세스 제어 블록

- 프로세스 제어 블록 - 프로세스를 실행하는 데 필요한 중요한 정보를 보관하는 자료구조로 TCB라고도 한다.

#### 2.1.1 프로세스 제어 블록의 구성

- 포인터 - 첫번째 블록에는 포인터가 저장된다.
- 프로세스 상태 - 두번째 블록에 저장되는 것으로, 생성, 준비, 실행, 대기, 보류 준비, 보류 대기 등이 있다.
- 프로세스 구분자 - 운영체제 내에 있는 여러 프로세스를 구별하기 위한 구분자를 저장한다.
- 프로그램 카운터 - 다음에 실행될 명령어의 위치를 가리키는 프로그램 카운터의 값을 저장한다.
- 프로세스 우선순위 - 사용자의 프로세스보다 중요도가 큰 커널 프로세스는 우선순위기 높고, 사용자 프로세스끼리도 우선순위가 다르다. 대기 상태의 큐도 우선순위 별로 따로 운영된다.
- 각종 레지스터 정보 - 자신이 사용하던 레지스터의 중간 값을 보관한다.
- 메모리 관리 정보 - 프로세스가 메모리의 어디에 있는지 나타내는 메모리 위치 정보, 메모리 보호를 위해 사용하는 경계 레지스터 값과 한계 레지스터 값 등이 저장된다.
- 할당된 자원 정보 - 프로세스를 실행하기 위해 사용되는 입출력 자원이나 오픈 파일 등에 대한 정보를 말한다.
- 계정 정보 - 계정 번호, CPU 할당 시간, CPU 사용 시간 등이다.
- 부모 프로세스 구분자와 자식 프로세스 구분자 - 부모 프로세스를 가리키는 PPID와 자식 프로세스를 가리키는 CPID 정보도 저장된다.

#### 2.1.2 포인터의 역할

- 대기 상태에는 같은 입출력을 요구한 프로세스끼리 모아놓는다.
- 준비큐도 여러 개가 있다.

### 2.2 문맥 교환

#### 2.2.1 문맥 교환의 의미

- 문맥 교환 - CPU를 차지하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업을 말한다.
- 문맥 교환시 두 프로세스 제어 블록의 내용이 변경된다. 실행 상태에서 나가는 프로세스 제어 블록에는 지금까지의 작업 내용을 저장하고, 반대로 실행 상태로 들어오는 프로세스 제어 블록의 내용으로 CPU가 다시 세팅된다.

#### 2.2.2 문맥 교환의 절차

- 문맥 교환이 일어나는 경우는 매우 다양하다.
  - 주어진 시간을 다 사용할때, 인터럽트가 걸렸을 때 등이 있다.

## 3. 프로세스의 연산

- 이제 프로세스가 어떻게 생성되고 복사되는지 알아볼 것이다.
- 먼저 시스템 프롤그래밍을 이해해야 한다.

### 3.1. 프로세스의 구조

- 프로세스는 코드, 데이터, 스택으로 구성된다.
  - 코드 영역 - 프로그램의 본문이 기술된 곳으로 텍스트 영역이라고도 한다. 읽기 전용으로 처리된다.
  - 데이터 영역 - 변수나 파일 등 각종 데이터를 모아놓는 곳이다.
  - 스택 영역 - 운영체제가 프로세스를 실행하기 위해 부수적으로 필요한 데이터를 모아놓는 곳이다. 운영체제가 사용자의 프로세스를 작동하기 위해 유지하는 영역이므로 사용자에게는 보이지 않는다.

### 3.2 프로세스의 생성과 복사

- 프로세스는 프로그램을 실행할 때 생성된다. → 운영체제는 프로그램을 메모리로 가져와 코드영역에 넣고 프로세스 제어 블록을 생성한다. → 메모리에 데이터 영역과 스택 영역을 확보한 후 프로세스를 실행한다.
- 프로세스를 새로 생성하는 것뿐만 아니라 새로운 프로세스를 복사하는 방법도 있다.

#### 3.2.1 `fork()`시스템 호출의 개념

- `fork()` 시스템 호출은 실행 중인 프로세스로부터 새로운 프로세스를 복사하는 함수이다. → 똑같은 프로세스가 하나 더 만들어 진다.
- 속도가 새로 생성하는 것보다 빠르다.

#### 3.2.2 `fork()` 시스템 호출의 동작 과정

- `fork()`시스템 호출을 하면 프로세스 제어 블록을 포함한 부모 프로세스 영역의 대부분이 자식 프로세스에 복사되어 똑같은 프로세스가 만들어진다. 프로세스 제어 블록의 내용 중 일부는 변경되는데 다음과 같다
  - 프로세스 구분자 - 주민등록 번호와 같은 것으로 바뀐다.
  - 메모리 관련 정보 - 메모리의 위치가 다르므로 바뀐다.

#### 3.2.3 `fork()` 시스템 호출의 장점

- 프로세스의 생성 속도가 빠르다.
  - 자식 프로세스의 생성 속도가 빠르다.
- 추가 작업 없이 자원을 상속할 수 있다.
  - 부모 프로세스가 사용하던 모든 자원을 추가 작업 없이 자식 프로세스에 상속할 수 있다.
- 시스템 관리를 효율적으로 할 수 있다.
  - 자식 프로세스를 종료하면 자식이 사용하던 자원을 부모 프로세스가 정리할 수 있다.

#### 3.2.4 `fork()` 시스템 호출의 예

- `fork()`문 이전에 파일을 열거나 변수를 선언하면 이것이 모두 자식 프로세스에 상속된다는 것이다. 그러나 서로 동립적이다.

### 3.3 프로세스의 전환

- `fork()`시스템 호출로 요리를 복사한 후, 복사된 요리를 새로운 요리로 바꾸는 함수인 `exec()` 시스템 호출을 사용하면 된다.

#### 3.3.1 `exec()` 시스템 호출의 개념

- `exec()` 시스템 호출은 기존의 프로세스를 새로운 프로세스로 전환하는 함수이다.
- 프로세스는 그대로 둔 채 내용만 바꾸는 시스템 호출이다. 현재의 프로세스가 완전히 다른 프로세스로 전환된다.
- 목적 - 프로세스의 구조체를 재활용하기 위한 것이다.
  - 새로운 프로세스를 만드려면 프로세스 제어 블록을 만들고 메모리의 자리를 확보하는 과정이 필요하다. 또한 청소하기 위해 부모 자식 관계를 만들어야 한다.
  - 이미 만들어진 프로세스 제어 블록, 메모리 영역, 부모-자식 관계를 그대로 사용할 수 있어 편리하다.

#### 3.3.2 `exec()` 시스템 호출의 동작 과정

- 코드 영역에 있는 기존의 내용을 지우고 새로운 코드로 바꿔버린다. 또한 데이터 영역이 새로운 변수로 채워지고, 스택 영역이 리셋된다.
- 프로세스 제어 블록 중 프로세스 구분자, 부모 프로세스 구분자, 자식 프로세서 구분자, 메모리 관련 사항 등이 변하지 않지만 프로그램 카운터 레지스터 값을 비롯한 각종 레지스터와 용한 파일 정보가 모두 리셋된다.

#### 3.3.3 `exec()` 시스템 호출의 예

- 건너 뜀

### 3.4 프로세스의 계층 구조

- 유닉스의 예를 통해 프로세스의 계층 구조를 알아보자.

#### 3.4.1 유닉스 프로세스 계층 구조

- 유닉스에 커널이 처음 메모리에 올라와 부팅이 되면 커널 관련 프로세스를 여러 개 만드는데, 그중 init 프로세스는 전체 프로세스의 출발점이 된다. 나머지 프로세스를 init 프로세스의 자식으로 만든다.

#### 3.4.2 프로세스 계층 구조의 장점

- 여러 작업의 동시 처리
  - `fork()`와 `exec()`를 통해 login 프로세스를 여러개 만들거나 login 프로세스를 shell 프로세스로 만드는 등의 작업을 한다.
- 용이한 자원 회수
  - 프로세스를 계층 구조로 만들면 프로세스 간의 책임 관계가 분명해져서 시스템을 관리하기가 수월하다. 모든 프로세스를 부모-자식 관계로 만들면 자식 프로세스가 작업을 마쳤을 때 사용하던 자원을 부모 프로세스가 회수하면 된다.

#### 3.4.3 미아 프로세스

- 부모 프로세스는 자원을 회수하기 위해 자식 프로세스가 끝날 때까지 기다려야 한다. 그러나 부모 프로세스가 먼저 종료되거나 자식 프로세스가 비정상적으로 종료되어 부모 프로세스에 연락이 안 되는 경우도 있다. → 미아 프로세스
- 미아 프로세스 - 많아지면 자원 낭비가 된다. → OS는 반환되지 못한 자원을 회수하는 자원회수를 주기적으로 해야 한다.

## 4. 스레드

- 이 절에서는 스레드의 개념과 사용 예를 다양한 각도로 접근하여 살펴본다.

### 4.1 스레드의 개념

#### 4.1.1 스레드의 정의

- 프로세스의 작업 과정
  - OS는 코드와 데이터를 메모리에 가져오고, 프로세스 제어 블록을 생성하고, 작업에 필요한 메모리 영역을 확보한 후, 준비된 프로세스를 준비 큐에 삽입한다.
  - 프로세스가 생성되면 CPU 스케줄러는 프로세스가 해야 할 일을 CPU에 전달하고 실제 작업을 CPU가 수행한다. 이때 CPU 스케줄러가 CPU에 전달하는 일 하나가 스레드이다.
- ⇒ CPU가 처리하는 작업의 단위는 프로세스로부터 전달받은 스레드이다. 운영체제 입장에서의 작업 단위는 프로세스이고 CPU 입장에서의 작업 단위는 스레드인 것이다.
- ⇒ 프로세스의 입장에서의 정의 - 프로세스의 코드에 정의된 절차에 따라 CPU에 작업 요청을 하는 실행 단위이다.
- 작업을 상대적인 크기순으로 나열하면 job > task > operation이고, 처리 > 프로세스 > 스레드가 된다.

#### 4.1.2 프로세스와 스레드의 차이

- 프로세스끼리는 약하게 연결되어 있는 반면 스레드끼리는 강하게 연결되어 있다.
  - 프로세스 - 서로 영향을 크게 미치지 않는다.
  - 스레드 - 순서를 바꾸면 안된다. → 강하게 연결되어 있다.
- 멀티 태스크와 멀티 스레드의 차이
  - 멀티 태스크 - 독립적인 프로세스는 데이터를 주고 받을 때 프로세스간 통신(IPC)를 이용한다.
  - 멀티 스레드 - 스레드들이 동시에 작업을 하는 것이다. 스레드끼리는 강하게 연결되어 하나가 종료되면 다른 하나도 종료된다. 변수나 파일을 공유하고 전역 변수나 함수 호출 등의 방법등으로 스레드 간 통신을 한다.

#### 4.1.3 스레드 관련 용어

- 멀티 스레드 - 프로세스 내 작업을 여러 개의 스레드로 분할함으로써 작업의 부담을 줄이는 프로세스 운영 기법이다.
- 멀티 태스킹 - 운영체제가 CPU에게 작업을 줄 때 시간을 잘게 나누어 배분하는 기법이다. → 시분할 시스템이라고 한다.
- 멀티 프로세싱 - CPU를 여러개 사용하여 여러 개의 프로세스를 동시에 처리하는 작업 환경을 말한다. 병렬 처리에서의 슈퍼스칼라 기법과 같다.
- CPU 멀티 스레드 - 한 번에 하나씩 처리해야 하는 스레드를 파이프라인 기법을 이용하여 동시에 여러 스레드를 처리하도록 만든 병렬 처리 기법이다.

### 4.2 멀티스레드의 구조와 예

#### 4.2.1 멀티 스레드의 구조

- `fork()` 시스템 호출은 낭비적인 요소가 많다 - 코드 영역과 데이터 영역의 일부가 메모리에 중복되어 존재한다.
- 스레드는 이러한 멀티태스킹의 낭비 요소를 제거하기 위해 사용한다. ← 비슷한 일을 하는 2개의 프로세스를 만드는 대신 코드, 데이터 등을 공유하면서 여러 개의 일을 하나의 프로세스 내에서 하는 것이다.
- 프로세스는 정적인 영역과 동적인 영역으로 나뉜다.
  - 정적인 영역 - 프로세스가 실행되는 동안 바뀌지 않는 영역
  - 동적인 영역 - 스레드가 작업을 하면서 값이 바뀌거나 새로 만들어지거나 사라지는 영역, 레지스터, 스택, 힙
- 멀티 태스킹의 경우 필요 없는 정적 영역이 여러 개가 된다. 이를 해결하기 위해 멀티 스레드를 사용한다.

### 4.3 멀티스레드의 장단점

#### 4.3.1 멀티 스레드의 장점

- 자원의 낭비를 막고, 작업의 효율을 높일 수 있다.
- 하나의 프로세스를 여러 개의 스레드로 구성하면 복잡한 작업을 쉽게 처리할 수 있다.
- 요약
  - 응답성 향상 - 한 스레드가 입출력으로 인해 작업이 진행되지 않더라도 다른 스레드가 작업을 계속하여 사용자의 작업 요구에 빨리 응답할 수 있다.
  - 자원 공유 - 한 프로세스 내에서 독립적인 스레드를 생성하면 프로세스가 가진 자원을 모든 스레드가 공유하게 되어 작업을 원활하게 진행할 수 있다.
  - 효율성 향상 - 여러 개의 프로세스를 생성하는 것과 달리 멀티 스레드는 불필요한 자원의 중복을 막음으로써 시스템의 효율이 향상된다.
  - 다중 CPU 지원 - 2개 이상의 CPU를 가진 컴퓨터에서 멀티 스레드를 사용하면 다중 CPU가 멀티 스레드를 동시에 처리하여 CPU 사용량이 증가하고 프로세스의 처리 시간이 단축된다.

#### 4.3.2 멀티 스레드의 단점

- 멀티 스레드의 경우 모든 스레드가 자원을 공유하기 때문에 한 스레드에 만제가 생기면 전체 프로세스에 영향을 미친다. ↔ 반면 프로세스를 여러개 만드는 방식의 경우 상관이 없다.

### 4.4 멀티스레드 모델

- 프로세스는 커널 프로세스와 사용자 프로세스로 나뉘며 스레드에도 커널 스레드와 사용자 스레드가 있다
  - 커널 스레드 - 커널이 직접 생성하고 관리하는 스레드이다.
  - 사용자 스레드 - 라이브러리에 의해 구현된 일반적인 스레드이다.

#### 4.4.1 사용자 레벨 스레드

- 운영체제가 멀티 스레드를 지원하지 않을 떄 사용하는 방법으로 초기의 스레드 시스템에서 이용되었다. 라이브러리를 사용하여 구현하며, 라이브러리는 커널이 지원하는 스캐줄링이나 동기화 같은 기능을 대신 구현해준다.
- 커널 입장에서는 일반 프로세스이지만 커널이 하는 일을 라이브러리가 대신 처리하여 여러 개의 스레드를 작동한다. 따라서 사용자 프로세스 내에 여러 개의 스레드가 존재하지만 커널의 스레드 하나와 연결되기 때문에 1 to N 모델이라고 부른다.
- 문맥 교환과 같은 부가적인 작업이 줄어들어 속도가 빠르다.
- 단점
  - 단점은 여러 개의 스레드가 하나의 커널 스레드와 연결되기 때문에 커널 스레드가 입출력 작업을 위해 대기 상태에 들어가면 모든 사용자가 스레드가 같이 대기하게 된다는 것이다.
  - 또 다른 단점은 한 프로세스의 타임 슬라이스를 여러 스레드가 공유하기 때문에 여러 개의 CPU를 동시에 사용할 수 없다는 것이다.
  - 보안에 취약하다. 보호 장치를 라이브러리에서 구현해야하기 때문이다.

#### 4.4.2 커널 레벨 스레드

- 커널이 멀티 스레드를 지원하는 방식으로, 하나의 사용자 스레드가 하나의 커널 스레도와 연결되기 때문에 1 to 1 모델이라고 부른다.
- 장단점은 사용자 레벨 스레드의 장단점과 반대이다.
- 멀티 CPU를 사용할 수 있고, 대기 상태에 있어도 다른 스레드는 작업을 계속할 수 있다. 커널 기능으로 보안에 강하다.
- 하지만 문맥 교환을 할 때 오버헤드 때문에 느리게 작동한다.

#### 4.4.3 멀티 레벨 스레드

- 사용자 레벨 스레드와 커널 레벨 스레드를 혼합한 방식이므로 M to N 모델이라고 부른다.
- 사용자 레벨 스레드와 커널 레벨 스레드의 장단점을 모두 가지고 있다.
- 하나가 대기 들어가면 다른 하나가 대신하면 된다.
- 하지만 커널 레벨 스레드를 같이 사용하기 때문에 문맥 교환시 오버헤드가 있어 사용자 레벨 스레드만큼 빠르지 않다.
- 빠르게 움직여야 하는 스레드는 사용자 레벨 스레드로 작동하고, 안정적으로 움직여야 하는 스레드는 컨러 레벨 스레드로 작동한다.
