---
layout: post
title: "[OS] Chapter 2 컴퓨터의 구조와 성능 향상"
category: [OS]
date: 2024-08-01 20:50:00 +0900
tag: [OS, book]
description: summary of OS chapter 2
comments: false
---

이 장에서는 운영체제와 관련된 하드웨어의 특성과 동작 원리를 살펴본다.

## 1. 컴퓨텅 기본 구성

### 1.1 하드웨어의 구성

- 구성
  - 필수 장치 - 중앙처리장치와 메인메모리
  - 주변 장치 - 키보드, 마우스, 모니터, ...
- 메인 메모리는 전력이 끊기면 데이터를 잃어버리기 때문에 데이터를 영구히 보관하려면 하드 디스크가 필요하다. → 메인 메모리 (제1저장장치), 하드디스크(제2저장장치, 보조저장장치)
- 이 책에서는 메인 메모리를 메모리, 보조 저장장치를 저장장치, 중앙처리장치를 CPU라고 한다.

#### 1.1.1 CPU와 메모리

- CPU - 명령어를 해석하여 실행하는 장치
- 메모리 - 작업에 필요한 프로그램과 데이터를 저장하는 장소로, 바이트 단위로 분할되어 있으며 분할 공간마다 주소로 구분한다.

#### 1.1.2 입출력장치

- 말 그대로 입출력 장치이다.
- 그래픽 카드에 GPU를 달아서 직접 계산하게 되었다. → GPU는 그래픽용 CPU이다.

#### 1.1.3 저장장치

- 느리다. ← 쓰는 이유는 싸기 때문이다.
- 저렴, 용량 거대, 전원 유무 상관 없음

#### 1.1.4 메인보드

- 컴퓨터의 다양한 부품은 버스로 연결된다. → 각 장치를 연결하는 선의 집합이자 데이터가 지나다니는 통로이다.

### 1.2 폰노이만 구조

- 오늘날의 컴퓨터는 대부분 폰노이만 구조를 따른다.
- CPU와 메모리, 입출력장치, 저장장치가 버스로 연결되어 있는 구조이다.
- 하드웨어를 그대로 둔 채 작업을 위한 프로그램만 교체하여 메모리에 올리는 방식
- 모든 프로그램은 메모리에 올라와야 실행할 수 있다. ← 저장장치에 있는 프로그램은 메모리에 올라와야 한다.

### 1.3 요리사 모형

- 요리사가 CPU, 도마가 메모리, 보관 창고는 저장장치로 비유된다.
- 메모리(도마)의 크기가 속도에 영향을 미친다, 도마의 크가가 크면 좋지만 너무 큰 것과 적당한 것의 차이는 적다.

### 1.4 하드웨어 사양 관련 용어

- 클록 - CPU의 속도와 관련된 단위, 클록이 일정한 간격으로 틱을 만들면 거기에 맞추어 CPU 안의 모든 구성 부품이 작업을 한다.
- 헤르츠 - 클록틱이 발생하는 속도를 나타내는 단위이다.
- 시스템 버스와 CPU 내부 버스 - 시스템 버스는 메모리와 주변 장치를 연결하는 버스로 FSB, 즉 전면 버스라고 한다. CPU 내부에 있는 장치를 연결하는 버스로 BSB, 즉 후면 버스라고 한다.

## 2. CPU와 메모리

### 2.1 CPU의 구성과 동작

#### 2.1.1 CPU의 기본 구성

- CPU - 산술논리 연산장치, 제어장치, 레지스터로 구성된다.
  - 산술 논리 연산장치 - 데이터 연산하는 장칭치다. 산술 연산, 논리 연산을 수행한다.
  - 제어장치 - 작업을 지시하는 부분이다.
  - 레지스터 - 데이터를 임시로 보관하는 곳

#### 2.1.2 CPU의 명령어 처리 과정

- CPU는 2진수으로 이루어진 기계어만 인식한다. → C언어 코드를 컴파일러로 기계어로 바꿔야한다. → 어셈블리어를 보며 이해하면 된다.

#### 2.1.3 레지스터의 종류

- 데이터 레지스터 - 메모리에서 가져온 데이터를 임시로 보관할 때 사용한다. 대부분의 레지스터가 이 종류이다.
- 주소 레지스터 - 메모리의 주소를 저장하는 레지스터이다.
- 프로그램 카운터(PC) - 다음에 실행할 명령어의 주소를 기억하고 있다가 제어장치에 알려준다.
- 명령어 레지스터 (IR) - 현재 실행 중인 명령어를 저장한다. 제어장치는 명령어 레지스터에 있는 명령을 해석한 후 외부 장치에 적절한 제어 신호를 보낸다.
- 메모리 주소 레지스터 (MAR) - 주소를 저장하기 위해 사용한다.
- 메모리 버퍼 레지스터 (MBR) - 메모리에서 가져온 데이터나 메모리로 옮겨 갈 데이터를 임시로 저장한다.

#### 2.1.4 버스의 종류

- 제어 버스 - 다음에 어떤 작업을 할지 지시하는 제어 신호가 오고 간다.
- 주소 버스 - 메모리의 데이터를 읽거나 쓸 때 어느 위치에서 작업할 것인지를 알려주는 위치 정보(주소)가 오고 간다.
- 데이터 버스 - 제어버스가 다음 작업을 신호를 보내고 주소 버스가 위치 정보를 전달하면 데이터가 데이터 버스에 실려 목적지까지 이동한다.
- 버스의 대역폭 - 32bit, 64bit 등이 있다.

### 2.2 메모리의 종류와 부팅

- 메모리에 데이터를 읽거나 쓸 때는 워드 단위로 움직인다.

#### 2.2.1 메모리의 종류

- 램은 읽거나 쓸 수 있는 것, 롬은 읽기만 가능한 것
- 램은 비휘발성, 휘발성으로 나뉜다. 전력 공급의 유무
- 휘발성 메모리
  - DRAM - 일정 시간이 지나면 데이터가 사라져서 일정 시간마다 전력을 넣어서 재생 시켜야 한다.
  - SRAM - 전력이 공급되는 동안에는 데이터를 보관할 수 있어 재생할 필요가 없다. 속도는 빠르지만 가격이 비싸다.
  - 메인 메모리는 DRAM, 캐쉬 메모리는 SRAM
  - SDRAM - DRAM이 발전된 형태로 클록이 발생할 때마다 데이터를 저장하는 동기 DRAM이다.
- 비휘발성 메모리
  - 플래시 메모리, FRAM, PRAM등이 있다.
- 롬은 데이터를 한번 저장하면 바꿀 수 없다.

#### 2.2.2 메모리 보호

- 일괄 작업 시스템에서는 메모리가 운영체제 영역과 사용자 영역으로 구분된다.
- 요즘은 시분할 기법을 활용해 여러 프로그램을 동시에 실행한다.
- 메모리를 보호하기 위해 CPU는 현재 진행 중인 작업의 메모리 시작 주소를 경계 레지스터에 저장한 후 작업을 한다. 또한 현재 진행 중인 작업이 차지하고 있는 메모리의 크기, 즉 마지막 주소까지의 차이를 한계 레지스터에 저장한다.

#### 2.2.3 부팅

- 부팅 - 컴퓨터를 켰을 때 운영체제를 메모리에 올리는 과정
- 부팅 과정
  - 사용자가 전원을 켜면 롬에 저장된 바이오스가 실행된다.
  - 마스터 부트 레코드에 저장된 작은 프로그램을 메모리로 가져와 실행한다.
  - 마스터 부트 레코드는 하드 디스크의 첫번째 섹터를 가리키며, 운영체제를 실행하기 위한 코드인 부트 스트랩이 이곳에 저장되어 있다.
  - 부트 스트랩 코드는 운영체제를 메모리로 가져와 실행하는 역할을 하는 작은 프로그램이다.

## 3. 컴퓨터 성능 향상 기술

- 이 장에서는 장치간 속도 차이를 개선하고 시스템의 작업 속도를 올리기 위해 개발된 기술 중 운영체제와 관련된 기술을 살펴볼 것이다.

### 3.1 버퍼

#### 3.1.1 버퍼의 개념

- 일정량의 데ㅣ터를 모아 옮김으로써 속도 차이가 있는 두 장치 사이에서 그 차이를 완화하는 역할을 한다.
- 버퍼는 하드웨어적으로만 사용되는 개념이 아니다. 소프트웨어적으로도 사용된다.

#### 3.1.2 스풀

- 스풀은 CPU와 입출력장치가 독립적으로 동작하도록 고안된 SW적 버퍼로, 대표적인 예로 프린터에 사용되는 스풀러가 있다.

### 3.2 캐시

#### 3.2.1 캐시의 개념

- 캐시는 메모리와 CPU 간의 속도 차이를 완화하기 위해 메모리의 데이터를 미리 가져와 저장해두는 임시 장소이다.
- 버퍼의 일종으로 CPU가 사용할 것으로 예상되는 데이터를 미리 가져다 놓는다. → prefetch라고 부른다.
- 캐시에서 원하는 데이터를 찾으면 cache hit이라고 하고 없으면 cache miss라고 한다. 적중률을 cache hit ratio라고 하고 90%정도 된다.
- 성능 향상법
  - 캐시의 크기를 늘리는 방법
  - 앞으로 많이 사용될 데이터를 가져오는 것

#### 3.2.2 즉시 쓰기와 지연 쓰기

- 캐시의 변경된 데이터를 메모리에 반영하는 데에는 즉시 쓰기 방식과 지연 쓰기 방식이 있다.
- 즉시 쓰기 - 캐시가 변경되면 바로 메모리에 반영하는 방법이다. 빈번한 전송으로 성능이 느려지지만 급작스러운 정전에도 데이터를 잃어버리지 않는다.
- 지연 쓰기 - 변경된 내용을 모아서 주기적으로 반영하는 방식으로 copy back이라고도 한다. 성능이 향상되지만 불일치가 발생할 수도 있다.

#### 3.2.3 L1 캐시와 L2 캐시

- 프로그램 명령어는 명령어 부분과 데이터 부분으로 나눌 수 있다. → 캐시는 명령어와 데이터의 구분 없이 모든 자료를 가져오는 일반 캐시, 명령어와 데이터를 구분하여 가져오는 특수 캐시라는 두가지 레벨로 구분된다.
- 명령어 캐시는 명령어 레지스터와 연결되어 있고, 데이터 캐시는 데이터 레지스터와 연결되어 있다. L1 캐시가 CPU와 직접 연결되어 있고 L2 캐시는 메모리와 연결되어있다.

### 3.3 저장장치의 계층 구조

- 가격과 컴퓨터 성능 사이의 타협점으로 저장장치의 계층 구조가 존재한다. 속도가 빠르고 값이 비싼 것을 CPU와 가까이 두고, 싸고 용량이 큰 것을 반대 쪽에 배치한다.
- 일관성에 문제가 생길 수도 있고 갑자기 전원이 꺼지면 데이터를 잃어 버릴 수 있다.

### 3.4 인터럽트

#### 3.4.1 인터럽트의 개념

- 오래된 방법으로 CPU가 직접 입출력 장치에서 데이터를 가져오거나 내보내는 것을 폴링 방식이라고 한다. ← 작업 효율이 떨어진다.
- 폴링의 단점을 해결하기 위해 나온 것이 인터럽트 방식이다. ← CPU의 작업과 저장장치의 데이터 이동을 독립적으로 운영함으로써 시스템의 효율을 높인다.

#### 3.4.2 인터럽트 방식의 동작 과정

- 과정
  - CPU가 입출력 관리자에서 입출력 명령을 보낸다.
  - 입출력 관리자는 명령받은 데이터를 메모리에 가져다 놓거나 메모리에 있는 데이터를 저장장치로 옮긴다.
  - 데이터 전송이 완료되면 입출력 관리자는 완료 신호(인터럽트)를 CPU에게 보낸다.
- 많은 주변장치 중 어떤 것이 끝났는지를 CPU에게 알려주기 위해 인터럽트 번호를 사용한다.
- CPU가 입출력 관리자에게 여러 개의 입출력 작업을 동시에 시킬 수 있는데, 이때 작업이 완료될 때마다 인터럽트를 여러 번 사용하면 매우 비효율적이다. → 여러 개의 인터럽트를 하나의 매열로 만든 것이 인터럽트 배열이다.

#### 3.4.3 직접 메모리 접근

- CPU에게 명령을 받은 입출력 관리자는 메모리 접근 권한이 없다. 이러한 권한을 DMA라고 한다.

#### 3.4.4 메모리 매핑 입출력

- 직접 메모리 접근은 인터럽트 방식의 시스템을 구성하는데 필수 요소이다. → 메모리가 섞여있다. → 메모리를 나누어 사용하는 방법이 도입되었다.
- 메모리 매핑 입출력 - 메모리의 일정 공간을 입출력에 할당하는 기법

#### 3.4.5 사이클 훔치기

- CPU와 입출력 장치가 동시에 메모리에 접근하면 CPU가 양보한다. 이러한 상황을 사이클 훔치기라고 한다.

## 4. 병렬 처리

### 4.1 병렬 처리의 개념

- 병렬 처리 - 동시에 여러 개의 명령을 처리하여 작업의 능률을 올린는 방식
- 코어가 여러개인 CPU는 물론이고 코어가 하나인 CPU에서도 가능하다.
- 파이프라인 기법 - 하나의 코어에 여러 개의 스레드를 이용하는 방식
- 스레드 - CPU가 처리할 수 있는 작업의 단위를 나타내며, 여러 개의 스레드를 동시에 처리하는 방법을  CPU 멀티 스레드라고 한다.
- 슈퍼 스칼라 기법 - 한 CPU에 작업을 처리하는 코어가 2개 있고 2개의 작업을 동시에 처리할 수 있다.

### 4.2 병렬 처리 시 고려 사항

- 상호 의존성이 없어야 병렬처리가 가능하다.
- 각 단계의 시간을 거의 일정하게 맞춰야 병렬 처리가 원만하게 이루어진다.
- 작업 전체 시간을 몇 단계로 나눌지 잘 따져보아야 한다.

### 4.3 병렬 처리 기법

- CPU에서 명령어가 실행되는 괴정은 다음과 같이 4단계로 나눌 수 있다.
  - 명령어 패치 - 다음 실행할 명령어를 명령어 레지스터에 저장한다.
  - 명령어 해석 - 명령어를 해석한다.
  - 실행 - 해석한 결과를 토대로 명령어를 실행한다.
  - 쓰기 - 실행된 결과를 메모리에 저장한다.
- 병렬 처리 기법의 구분
  - 파이프라인 기법 - 하나의 코어에서 작업을 나누어 병렬로 처리하는 기법
  - 슈퍼 스칼라 기법 - 여러 개의 코어를 사용하여 동시에 작업을 진행하는 기법
  - 슈퍼 파이프라인 기법, 슈퍼 파이프라인 슈퍼 스칼라 기법, VLIW기법 등이 있다.

#### 4.3.1 파이프라인 기법

- 하나의 코어에 여러개의 스레드를 사용하는 것이다.
- 명령어를 여러 개의 단계로 분할한 후, 각 단계를 동시에 처리하는 하드웨어를 독립적으로 구성한다.
- 단계마다 독립적으로 구성하여 각 단계가 쉬지 않고 명령어를 처리한다.
- 파이프라인 위험 - 여러 가지 문제가 있다
  - 데이터 위험 - 데이터의 의존성 때문에 발생하는 문제이다. → 파이프라인의 명령어 단계를 지연하여 해결한다.
  - 제어 위험 - 프로그램 카운터 값을 갑자기 변화시켜 발생하는 위험이다. → 분기 예측이나 분기 지연 방법으로 해결한다.
  - 구조 위험 - 서로 다른 명령어가 같은 자원에 접근하려 할 때 발생하는 문제이다. → 해결하기 어렵다.
- 인텔 계열 CPU에서는 하이퍼쓰레드라고 부른다.

#### 4.3.2 슈퍼 스칼라 기법

- 파이프라인이 처리할 수 있는 코어를 여러 개 구성하여 복수의 명령어가 동시에 실행되도록 하는 방식이다.
- 대부분 파이프라인과 비슷하지만 코어를 2개 구성하여 각 단계에서 동시에 실행되는 명령어가 2개라는 점이 다르다.
- 오늘날의 대부분의 CPU가 쓰는 방법이다.

#### 4.3.3 슈퍼 파이프라인 기법

- 파이프라인 기법을 강화한 것이다. 파이프라인에서는 클록마다 하나의 명령어를 실행하지만, 슈퍼 파이프라인 기법에서는 파이프라인의 각 단계를 세분하여 한 클록 내에 여러 명령어를 처리할 수 있다.

#### 4.3.4 슈퍼 파이프라인 슈퍼 스칼라 기법

- 앞의 병렬 처리 기법을 모두 합쳐 놓은 것이다. 슈퍼파이프라인 기법을 여러개의 코어에서 동시에 수행하는 방식이다.

#### 4.3.5 VLIW 기법

- 지금까지의 병렬 처리기법과 완전히 다른 기법으로, CPU가 병렬처리를 지원하지 않는 경우 SW적으로 병렬 처리를 하는 방법이다.
- 동시에 수행할 수 있는 명령어들을 컴파일러가 추출하고 하나의 명령어로 압출하여 실행한다.
- 동시에 처리하는 명령어의 개수가 적다.
- 컴파일 시 병렬 처리가 이루어진다.
