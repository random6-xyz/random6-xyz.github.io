---
layout: post
title: "[OS] Chapter 7 물리 메모리 관리"
category: [OS]
date: 2024-08-21 16:15:00 +0900
tag: [OS, book]
description: summary of OS chapter 7
comments: false
---

메모리 관리와 메모리에 프로세스를 할당하는 방식을 살펴본다.

## 1. 메모리 관리의 개요

- 이 장에서 살펴볼 메모리는 메인 메모리를 가리킨다.

### 1.1 메모리 관리의 복잡성

- CPU는 메모리에 이쓴 내용을 가져오거나 작업 결과를 메모리에 저장하기 위해 메모리 주소 레지스터(MAR)를 사용한다. 메모리 주소 레지스터에 필요한 메모리 주소를 넣으면 데이터를 메모리에서 가져오거나 옮긴다.
- 메모리에는 사용자의 프로세스뿐 아니라 운영체제 프로세스도 공존한다.
- 이 장에서 살펴볼 메모리 관리는 운영체제를 비롯해 여러 작업을 동시에 처리할 때 메모리를 어떻게 관리하는가에 관한 문제이다. → 메모리 관리 시스템이 담당한다.

### 1.2 메모리 관리의 이중성

- 메모리 관리의 이중성이란 프로세스 입장에서는 메모리를 독차지하려 하고, 메모리 관리자 입장에서는 되도록 관리를 효율적으로 하고 싶어 하는 것을 말한다.
- 프로세스  입장에서 작업의 편리함과 관리자 입장에서 관리의 편리함이 충돌을 일으키는 것을 말한다.

### 1.3 소스코드의 번역과 실행

#### 1.3.1 컴파일러와 인터프린터의 동작

- 언어 번역 프로그램
  - 컴파일러 - 소스코드를 컴퓨터가 실행할 수 있는 기계어로 번역한 후 한꺼번에 실행한다.
  - 인터프리터 - 소스코드를 한 행씩 번역하여 실행한다.

#### 1.3.2 컴파일러의 목적

- 오류 발견 - 소스코드에서 오류를 발견하여 실행 시 문제가 없도록 하는 것이다. 컴파일러는 오류를 찾기 위해 심벌 테이블을 사용한다.
- 코드 최적화 - 군더더기와 사용하지 않는 변수를 삭제하면 더욱 간결해져서 실행 속도가 빨라진다.

#### 1.3.3 컴파일러와 인터프리터의 차이

- 크고 복잡한 프로그램에는 컴파일러를 사용하고 간단한 프로그램에는 인터프리터를 사용한다.

#### 1.3.4 컴파일 과정

- 컴파일은 사용자가 작성한 소스코드를 목적 코드로 변환한 후 라이브러리를 연결하고 최종 실행 파일을 만들어 실행하는 과정이다.
- 동적 라이브러리 - 실행할 때 삽입되는 함수를 가진 라이브러리

### 1.4 메모리 관리자의 역할

- 메모리 관리자는 메모리 관리 유닛(MMU)이고 작업은 가져오기, 배치, 재배치이다.
  - 가져오기 - 프로세스와 데이터를 메모리로 가져오는 작업이다.
  - 배치 작업 - 가져온 프로세스와 데이터를 메모리의 어떤 부분에 올려놓을지 결정하는 작업이다.
  - 재배치 작업 - 꽉 차있는 메모리에 새로운 프로세스를 가져오기 위해 오래된 프로세스를 내보내는 작업
- 정책
  - 가져오기 정책 - 프로세스가 필요로 하는 데이터를 언제 메모리로 가져올지 결정하는 정책이다. → 요청할때와 미리 가져오는 방식이 있다.
  - 배치 정책 - 가져온 프로세스를 메모리의 어떤 위치에 올려놓을지 결정하는 정책이다. 메모리를 같은 크기로 자르는 것을 페이징이라고 하며, 프로세스의 크기에 맞게 자르면 세그먼트라고 한다.
  - 재비치 정책 - 메모리가 꽉 찼을 때 메모리 내에 있는 어떤 프로세스를 내보낼지 결정하는 정책이다. 앞으로 사용하지 않을 프로세스를 찾아서 내보내는 알고리즘을 교체 알고리즘이라고 한다.

## 2. 메모리 주소

- 이 절에서는 메모리 주소는 절대 주소와 상대 주소로 나뉘는데 둘의 차이와 주소를 지정하는 방법을 살펴본다.

### 2.1 32bit CPU와 64bit CPU의 차이

- CPU의 비트는 한 번에 다룰 수 있는 데이터의 최대 크기를 의미한다.
- 32bit의 경우 메모리 주소를 지정하는 레지스터인 메모리 주소 레지스터의 크기가 32bit이므로 표현할 수 있는 메모리 주소의 범위가 4gb이다. 그래서 최대 4gb만큼만 메모리를 사용할 수 있다.
- 컴퓨터에는 메모리가 설치되며 각 메모리 주소 공간이 있다. 이렇게 설치된 메모리의 주소 공간을 물리 주소 공간이라고 한다. 물리 주소 공간은 하드웨어 입장에서 바라본 주소 공간으로 컴퓨터마다 그 크기가 다르다. 이와 반대로 사용자 입장에서 바라본 주소 공간은 논리 주소 공간이라고 한다.

### 2.2 절대 주소와 상태 주소

#### 2.2.1 메모리 영역의 구분

- 단순 메모리 구조는 한 번에 한 가지 일만 처리하는 일괄 처리 시스템에서 볼 수 있다. 운영체제 영역과 사용자 영역으로 나누어 관리한다.
- 사용자 영역이 운영체제 영역으로 침범하는 것을 막으려면 하드웨어의 도움이 필요한데, 이는 CPU 내에 있는 경계 레지스터가 담당한다.

#### 2.2.2 절대 주소와 상대 주소의 개념

- 컴파일할 당시에는 변수가 메모리의 어느 위치에 올라가는 지 알 수 없기 때문에 0번지부터 배정하고 실제로 실행할 때 주소를 조정한다.
- 실제 물리적 주소를 가리키는 절대 주소는 메모리 관리자 입장에서 바라본 주소이다. 메모리 관리자는 절대 주소를 사용하지만 사용자 입장에서는 불편하고 위험하다.
- 상대 주소는 사용자 영역이 시작되는 번지를 0번지로 변경하여 사용하는 주소 지정 방식이다. 사용자 프로세스 입장에서 바라본 주소이다.

#### 2.2.3 상대 주소를 절대 주소로 변환하는 과정

- 메모리 관리자는 사용자 프로세스가 상대 주소를 사용하여 메모리에 접근할 때마다 상대 주소값에 재배치 레지스터 값을 더하여 절대 주소를 구한다.

## 3. 단일 프로그래밍 환경에서의 메모리 할당

### 3.1 메모리 오버레이

- 프로그램의 크기가 실제 메모리보다 클 때 전체 프로그램을 메모리에 가져오는 대신 적당한 크기로 잘라서 자겨오는 기법을 메모리 오버레이라고 한다. → 하나의 메모리에 여러 프로그램을 겹겹이 쌓아놓고 실행하는 것을 말하다.
- 메모리 오보레이의 경우 프로그램을 몇 개의 모듈로 나누고 필요할 때마다 모듈을 메모리에 가져와 사용한다.
- 메모리 오버레이에서 어떤 모듈을 가져오거나 내보낼지는 PC레지스터가 결정한다.
- 메모리 오버레이의 중요한 의미
  - 한정된 메모리에서 메모리보다 큰 프로그램의 실행이 가능하다. → 가상 메모리 시스템의 기본이 되는 개념이다.
  - 프로그램 전체가 아니라 일부만 메모리에 올라와도 실행이 가능하다.

### 3.2 스왑

- 메모리가 모자라서 쫓겨난 프로세스는 저장장치의 특별한 공간에 모아두는데 이러한 영역을 스왑 영역이라고 부른다.
- 스왑 영역에서 메모리로 데이터를 가져오는 작업을 스왑인, 반대를 스왑아웃이라고 한다.
- 스왑 영역은 메모리 관리자가 관리한다.
- 사용자는 실제 메모리의 크기와 스왑 영역의 크기를 합쳐서 전체 메모리로 인식하고 사용할 수 있다.

## 4. 다중 프로그래밍 환경에서의 메모리 할당 - 366

- 이 절에서는 한 번에 여러 프세스가 실행되는 구조의 메모리 문제를 알아본다.

### 4.1 메모리 분할 방식

- 메모리를 어떤 크기로 나눌 것인가는 메모리 배치 정책에 해당된다.
  - 가변 분할 방식 - 프로세스의 크기에 따라 메모리를 나누는 것
  - 고정 분할 방식 - 프로세스의 크기와 상관없이 메모리를 같은 크기로 나누는 것

#### 4.1.1 가변 분할 방식과 고정 분할 방식

- 가변 분할 방식은 관리 측면에서 불편하지만 고정 분할 방식의 경우에는 관리가 수월하다.

#### 4.1.2 메모리 분할 방식의 구현

- 가변 분할 방식 - 프로세스의 크기에 맞게 메모리가 분할되므로 메모리의 영역이 각각 다르다. 연속 메모리 할당이라고 한다.
- 고정 분할 방식 - 프로세스의 크기에 상관없이 메모리가 같은 크기로 나뉘며, 큰 프로세스가 메모리에 올라오면 여러 조각으로 나뉘어 배치된다. 비연속 메모리 할당이라고 한다.
- 장단점
  - 가변 분할 방식
    - 장점 - 프로세스를 한 덩어리로 처리하여 하나의 프로세스를 연속된 공간에 배치한다.
    - 단점 - 메모리 관리가 복잡하다. 메모리 통합 등의 부가적인 작업이 필요하다.
  - 고정 분할 방식
    - 장점 - 메모리를 일정 크기로 나누어 관리하기 때문에 메모리 관리가 수월하다. 부가적인 작업을 할 필요가 없다.
    - 단점 - 쓸모없는 공간으로 인해 메모리 낭비가 발생할 수 있다. 일정하게 나누어진 공간보다 작은 프로세스가 올라올 경우 메모리 낭비가 발생한다.
- 현대 운영체제에서 메모리 관리는 기본적으로 고정 분할 방식을 사용하면서 일부분은 가변 분할 방식을 혼합하고 있다.

### 4.2 가변 분할 방식의 메모리 관리

- 가상 메모리 시스템에서 가변 분할 방식은 세그먼테이션 기법이라고도 한다.

#### 4.2.1 프로세스 배치와 외부 단편화

- 가변 분할 방식에서 발생하는 작은 빈 공간을 외부 단편화라고 한다.
- 이러한 문제를 해결하기 위해 메모리 배치 방식이나 조각 모음을 사용한다.
- 메모리 배치 방식은 가변 분할 방식에서 선처리에 해당하고 조각 모음은 후처리에 해당한다.

#### 4.2.2 메모리 배치 방식

- 가변 분할 방식의 외부 단편화 문제를 해결하기 위한 대표적인 메모리 배치 방식으로는 최초 배치, 최적 배치, 최악 배치가 있다. 이 외에도 버디 시스템이 있다.
  - 최초 배치 - 단편화를 고려하지 않은 것으로, 프로세스를 메모리의 빈 공간에 배치할 때 메모리에서 적재 가능한 공간으 순서대로 찾다가 첫 번째로 발견한 공간에 프로세스를 배치하는 방법
  - 최적 배치 - 메모리의 빈 공간을 모두 확인한 후 적당한 크기 가운데 가장 작은 공간에 프로세스를 배치하는 방법이다.
  - 최악 배치 - 빈 공간을 모두 확인한 후 가장 큰 공간에 프로세스를 배치하는 방법이다.

#### 4.2.3 조각 모음

- 위 3가지 메모리 배치 방식을 사용해도 단편화 현상이 발생한다. 메모리 배치 방식은 근복적으로 메모리 관리의 효율성을 높이는 것을 해결하지 못한다.
- 단편화가 발생하면 이미 매치된 프로세스를 옆으로 옮겨 빈 공간들을 하나의 큰 덩어리로 만들어야 하는 것이 바로 조각 모음이다.
- 순서
  - 조각 모음을 하기 위해 이동할 프로세스의 동작을 멈춘다.
  - 프로세스를 적당한 위치로 이동한다. 프로세스의 상대 주소값을 바꾼다.
  - 이러한 작업을 다 마친 후 프로세스를 다시 시작한다.
- 많은 시간이 걸린다.

### 4.3 고정 분할 방식의 메모리 관리

- 가상 메모리 시스템에서는 고정 분할 방식을 페이징이라고도 한다. 같은 크기로 나누기 때문에 편하지만 프로세스가 메모리의 여러 조각에 나뉘어 저장되는 것이 문제이다.

#### 4.3.1 프로세스 배치와 내부 단편화

#### 4.3.2 내부 단편화

- 일정하게 나뉜 메모리의 크기보다 작은 프로세스가 배치될 경우 낭비되는 공간이 생긴다.
- 메모리 조각에 프로세스를 배치하고 공간이 남는 현상을 내부 단편화라고 한다.
- 동일하게 분할되는 공간의 크기를 조절하여 내부 단편화를 최소한다.

### 4.4 버디 시스템

- 가변 분할 방식의 단점인 외부 단편화를 완화하는 방법으로 버디 시스템이 있다.

#### 4.4.1 버디 시스템의 작동 방식

- 버디 시스템의 특징은 가변 분할 방식과 고정 분할 방식의 중간 구조라는 것이다.
- 작동 방식
  - 프로세스의 크기에 맞게 메모리를 1/2로 자르고 프로세스를 메모리에 배치한다.
  - 나뉜 메모리의 각 구역에는 프로세스가 1개만 들어간다.
  - 프로세스가 종료되면 주변의 빈 조각과 합쳐서 하나의 큰 덩어리를 만든다.

#### 4.4.2 버디 시스템의 특징

- 가변 분할 방식처럼 메모리가 프로세스 크기대로 나뉘며, 고정 분할 방식처럼 하나의 구역에 다른 프로세스가 들어갈 수 없고, 메모리의 한 구역 내부에 조각이 생겨 내부 단편화가 발생한다.
- 버디 시스템이 가변 분할 방식보다 효과적으로 공간을 관리할 수 있는 이유는 비슷한 크기의 덩어리가 서로 모여 있어 통합하기가 쉽기 때문이다.
- 효율적인 공간 관리 측면에서 보면 고정 분할 방식과 버디 시스템은 비슷한 수준이다. 그러나 고정 분할 방식이 메모리 관리 측면에서 단순하기 때문에 버디 시스템보다 고정 분할 방식이 많이 사용되고 있다.
